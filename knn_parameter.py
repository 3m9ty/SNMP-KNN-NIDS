# -*- coding: utf-8 -*-
"""KNN_parameter.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1GW3x-NJovwxSECkEhzCutWMXN1k92DuB
"""

import os
import re
import csv
import sys
import mmap
import time
import numpy as np
import pandas as pd
import seaborn as sns
from joblib import dump
import matplotlib.pyplot as plt
from sklearn import metrics
from sklearn import preprocessing
from sklearn.decomposition import PCA
from sklearn.preprocessing import LabelEncoder
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.metrics import confusion_matrix

#######################################################
##########  Select the amount of file   ######
#######################################################

amount = int(input("Select amounts of input data: "))
file_amount = int((amount-1)*5) ###Network type has 5 type
oid_amount = 38 ###One file has 38 OID  
 
#######################################################
#####  Make dictionary for OID and label ######
#######################################################

oid = ['.3.6.1.2.1.2.2.1.10.2','.3.6.1.2.1.2.2.1.10.24','.3.6.1.2.1.2.2.1.11.2','.3.6.1.2.1.2.2.1.11.24',
	'.3.6.1.2.1.2.2.1.16.2','.3.6.1.2.1.2.2.1.16.24','.3.6.1.2.1.2.2.1.17.2','.3.6.1.2.1.2.2.1.17.24',
	'.3.6.1.2.1.4.3.0','.3.6.1.2.1.4.9.0','.3.6.1.2.1.4.10.0','.3.6.1.2.1.4.11.0',
	'.3.6.1.2.1.4.31.1.1.3.1','.3.6.1.2.1.4.31.1.1.5.1','.3.6.1.2.1.4.31.1.1.18.1','.3.6.1.2.1.4.31.1.1.20.1',
	'.3.6.1.2.1.4.31.1.1.25.1','.3.6.1.2.1.4.31.1.1.30.1','.3.6.1.2.1.4.31.1.1.32.1','.3.6.1.2.1.5.1.0',
	'.3.6.1.2.1.5.3.0','.3.6.1.2.1.5.9.0','.3.6.1.2.1.5.14.0','.3.6.1.2.1.5.15.0',
	'.3.6.1.2.1.5.16.0','.3.6.1.2.1.5.22.0','.3.6.1.2.1.5.29.1.2.1','.3.6.1.2.1.5.29.1.4.1',
	'.3.6.1.2.1.5.29.1.5.1','.3.6.1.2.1.5.30.1.3.1.3','.3.6.1.2.1.5.30.1.3.1.8','.3.6.1.2.1.5.30.1.4.1.0',
	'.3.6.1.2.1.5.30.1.4.1.3','.3.6.1.2.1.6.10.0','.3.6.1.2.1.6.11.0','.3.6.1.2.1.6.12.0',
	'.3.6.1.2.1.6.15.0','.3.6.1.2.1.7.2.0'] #每行4組OID
OID_dict = dict()
count = 0
for i in oid:
  OID_dict[count] = i
  count += 1

label_dict = {0:'normal',1:'tcp',2:'arp',3:'udp',4:'icmp'}

##############################################################################
##########    Filte OID octet and put it in list     #########
##############################################################################

data_type = ['normal','tcp','arp','udp','icmp']

for n in range(len(data_type)):  
  for i in range(1,1+amount): 
  	
    ##### Load the OID file #####
    #file = open('/content/drive/MyDrive/mib_0901/' + data_type[n] + str(i))     
    file = open('/home/lab/SNMP/knnd_new/MIB'+ data_type[n] + str(i))  
    iter_file = iter(file) 

    ### Create a global variable(list) ###    
    globals()[data_type[n] + str(i)] = [] 
    ### Use 'name' to replace compound string ###
    name = globals()[data_type[n] + str(i)]

    #####  Capture "Counter32" volume #####
    ### OID EX."iso.3.6.1.2.1.2.2.1.10.14 = Counter32: 64"
    for line in iter_file:
      iso = line.find('iso')
      if iso < 0:
        print("MIB ERROR : 'iso' not found")
        break

      Equal = line.find('=')
      if iso < 0:
        print("MIB ERROR : '=' not found")
        break

      state = 0
      Counter = line.find('Counter32: ')  
      if Counter < 0:
      #if OID output this messages
      	if line.find('No Such Instance currently exists at this OID\\') < 0:
      		Packet = 0  # If OID not exists, set 0.
      		state = 1
      	else:
      		print("MIB ERROR : 'Counter32' not found")
      		break
      if state == 0:
      	Packet = line[Counter + 11:]
      OID = line[iso + 3: Equal - 1]
      
      dict_append = True
      for i in range(len(OID_dict)):
        ### Detect OID whether exist in dictionary###
        if OID == OID_dict[i]:
          if(i >18 and i < 33):
            name.append([i,int(Packet)*100])
            dict_append = False
            break
          else:
            ### Append the dict index and packet value to list ###
            name.append([i,Packet])       
            dict_append = False
            break                                                      
      ### Add new OID to OID_dict ###   
      if dict_append is True:  
        OID_dict[len(OID_dict)] = OID
        ### The (lenth - 1) also is new OID index ### 
        name.append([len(OID_dict)-1,Packet])
        
    file.close()
print("##### OID filte END #####")

##############################################################################
######## Counting feature and create the training dataset.  #########
##############################################################################


##### Create feature and label dataset #####
x_data = np.empty((file_amount, oid_amount, 2))
y_data = np.empty(file_amount)

### y and z variable for loop  ###
y = 0
z = 0

for n in range(len(data_type)):
  for i in range(1,amount):
    
    ##### Use two file to counting value's delta as feature ######
    f1 = globals()[data_type[n] + str(i)]
    f2 = globals()[data_type[n] + str(i+1)]
    
    for j in range(len(f1)):
      for k in range(len(f2)):
        ### Before count, compare the OID ###
        if str(f1[j][0]) == str(f2[k][0]):           
          delta = (int(f2[k][1]) - int(f1[j][1])) / 20 #20s
          x_data[y][z][0] = f1[j][0] 
          x_data[y][z][1] = delta 
          z += 1
          continue  
    z = 0 #Reset z for next loop  

    y_data[y] = n #Variable 'n' equal the label_dict index
    y += 1
            
print("##### Feature Counting END #####")

### Original dataset is 3d, need reshape to 2d ###
x,y,z = np.shape(x_data)
x_data = x_data.reshape(x,y*z)

# Best parameter find #

best_parameter_tmp = [0,0,0,0,0,0,0] #[test_size, cv, k, test_score, cv_score, score_sum, best_parameter_group]
anime = ["[□ □ □ □ □ □ □ ]","[■ □ □ □ □ □ □ ]","[■ ■ □ □ □ □ □ ]", "[■ ■ ■ □ □ □ □ ]", "[■ ■ ■ ■ □ □ □ ]", "[■ ■ ■ ■ ■ □ □ ]", "[■ ■ ■ ■ ■ ■ □ ]", "[■ ■ ■ ■ ■ ■ ■ ]"]
ts = [0.15, 0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5]
z = 0
u = 0
v = 0
parameter = []
parameter_num = []

#cross validation
cv_scores = []

#test result
test_scores = []

cv = [2, 5, 10]
while u < 3:
  while z < 8:

    #cut train set and test set
    dx_train,dx_test,dy_train,dy_test = train_test_split(x_data,y_data,test_size=ts[z],random_state=0)
    #print(y_data)

    #x-axis of plot
    x = np.arange(4) + 1

    #knn train loop with cross validation
    for k in x:
      knn = KNeighborsClassifier(n_neighbors = k).fit(dx_train, dy_train)
      cv_scores.append(cross_val_score(knn, dx_train, dy_train, cv = cv[u]).mean())
      test_scores.append(knn.score(dx_test, dy_test)) 
      parameter.append((cv[u],ts[z],k))
      parameter_num.append(v)
      

      if(cv_scores[v] + test_scores[v] > best_parameter_tmp[5]):
        best_parameter_tmp[0] = ts[z]
        best_parameter_tmp[1] = cv[u]
        best_parameter_tmp[2] = k
        best_parameter_tmp[3] = test_scores[v]
        best_parameter_tmp[4] = cv_scores[v]
        best_parameter_tmp[5] = cv_scores[v] + test_scores[v]
        best_parameter_tmp[6] = v
      v += 1
    sys.stdout.write("\rAnalyzing" + anime[z])
    sys.stdout.flush()

    z += 1
  u += 1
  z = 0

print("\n\nBest test_size  = " + str(best_parameter_tmp[0]))
print("Best cv      = " + str(best_parameter_tmp[1]))
print("Best k      = " + str(best_parameter_tmp[2]))
print("Best test_score = " + str(best_parameter_tmp[3]))
print("Best cv_score  = " + str(best_parameter_tmp[4]))
print("\n")

#Best model train

dx_train,dx_test,dy_train,dy_test = train_test_split(x_data,y_data,test_size=best_parameter_tmp[0],random_state=0)

knn = KNeighborsClassifier(n_neighbors = best_parameter_tmp[2]).fit(dx_train, dy_train)

#print(knn.predict(dx_test))
#print('\n')
#print(dy_test)
#print('\n')
#output the confusion_matrix
print("Show the Confusion_Matrix\n")
print(confusion_matrix(knn.predict(dx_test), dy_test))


##### After model training, Export the Model ######
dump(knn, '/home/lab/SNMP/knn&detection_new/knn.joblib') 

# Confusion Matrix #
# xx -> actual,predict
nn, na ,ni ,nt ,nu ,an ,aa ,ai ,at ,au ,ino ,ia ,ii ,it ,iu ,tn ,ta ,ti, tt, tu, un, ua, ui, ut, uu = confusion_matrix(knn.predict(dx_test), dy_test).ravel()
#print(nn, na ,ni ,nt ,nu ,an ,aa ,ai ,at ,au ,ino ,ia ,ii ,it ,iu ,tn ,ta ,ti, tt, tu, un, ua, ui, ut, uu)
print('\n')

Accuracy_normal = (nn+aa+ai+at+au+ia+ii+it+iu+ta+ti+tt+tu++ua+ui+ut+uu)/(nn+na+ni+nt+nu+an+aa+ai+at+au+ino+ia+ii+it+iu+tn+ta+ti+tt+tu+un+ua+ui+ut+uu)
Accuracy_arp = (aa+nn+ni+nt+nu+ino+ii+it+iu+tn++ti+tt+tu+un+ui+ut+uu)/(nn+na+ni+nt+nu+an+aa+ai+at+au+ino+ia+ii+it+iu+tn+ta+ti+tt+tu+un+ua+ui+ut+uu)
Accuracy_icmp = (ii+nn+na+nt+nu+an+aa+at+au+tn+ta+tt+tu+un+ua+ut+uu)/(nn+na+ni+nt+nu+an+aa+ai+at+au+ino+ia+ii+it+iu+tn+ta+ti+tt+tu+un+ua+ui+ut+uu)
Accuracy_tcp = (tt+nn+na+ni+nu+an+aa+ai+au+ino+ia+ii+iu+un+ua+ui+uu)/(nn+na+ni+nt+nu+an+aa+ai+at+au+ino+ia+ii+it+iu+tn+ta+ti+tt+tu+un+ua+ui+ut+uu)
Accuracy_udp = (uu+nn+na+ni+nt+an+aa+ai+at+ino+ia+ii+it+tn+ta+ti+tt)/(nn+na+ni+nt+nu+an+aa+ai+at+au+ino+ia+ii+it+iu+tn+ta+ti+tt+tu+un+ua+ui+ut+uu)


Recall_normal = nn /(nn+na+ni+nt+nu)
Recall_arp = aa /(an+aa+ai+at+au)
Recall_icmp = ii /(ino+ia+ii+it+iu)
Recall_tcp = tt /(tn+ta+ti+tt+tu)
Recall_udp = uu /(un+ua+ui+ut+uu)

Precision_normal = nn /(nn+an+ino+tn+un)
Precision_arp = aa /(na+aa+ia+ta+ua)
Precision_icmp = ii /(ni+ai+ii+ti+ui)
Precision_tcp = tt /(nt+at+it+tt+ut)
Precision_udp = uu /(nu+au+iu+tu+uu)

F1_normal = 2 /((1/ Precision_normal) + (1/ Recall_normal))
F1_arp = 2 /((1/ Precision_arp) + (1/ Recall_arp))
F1_icmp = 2 /((1/ Precision_icmp) + (1/ Recall_icmp))
F1_tcp = 2 /((1/ Precision_tcp) + (1/ Recall_tcp))
F1_udp = 2 /((1/ Precision_udp) + (1/ Recall_udp))

print("Accuracy_normal: " + str(Accuracy_normal))
print("Accuracy_arp: " + str(Accuracy_arp))
print("Accuracy_icmp: " + str(Accuracy_icmp))
print("Accuracy_tcp: " + str(Accuracy_tcp))
print("Accuracy_udp: " + str(Accuracy_udp))
print('\n')
print("Precision_normal: " + str(Precision_normal))
print("Precision_arp: " + str(Precision_arp))
print("Precision_icmp: " + str(Precision_icmp))
print("Precision_tcp: " + str(Precision_tcp))
print("Precision_udp: " + str(Precision_udp))
print('\n')
print("Recall_normal: " + str(Recall_normal))
print("Recall_arp: " + str(Recall_arp))
print("Recall_icmp: " + str(Recall_icmp))
print("Recall_tcp: " + str(Recall_tcp))
print("Recall_udp: " + str(Recall_udp))
print('\n')
print("F1_normal: " + str(F1_normal))
print("F1_arp: " + str(F1_arp))
print("F1_icmp: " + str(F1_icmp))
print("F1_tcp: " + str(F1_tcp))
print("F1_udp: " + str(F1_udp))

# plot present #

plt.figure(figsize=(40,16))
plt.title('parameter',fontsize=24)
plt.plot(parameter_num, cv_scores, label = 'CV score')
plt.plot(best_parameter_tmp[6] - 1, best_parameter_tmp[4], 'gd')
plt.plot(parameter_num, test_scores, label = 'Test score')
plt.xlabel('[cv,test_size,k]',fontsize=24)
plt.ylabel('accuracy (%)',fontsize=24)
plt.text(best_parameter_tmp[6] - len(parameter_num)/50, best_parameter_tmp[4] + 0.02,parameter[best_parameter_tmp[6]], fontsize = 20)
plt.legend(fontsize=24, loc = 3)
plt.grid(True)
plt.show()


